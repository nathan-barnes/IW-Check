var FragmentShader = (function () {
    function FragmentShader() {
    }
    FragmentShader.code = "\n\tprecision mediump float;\n\tprecision mediump int;\n\tuniform vec3 materialColor;\n\tuniform sampler2D materialTexture;\n\tuniform int useMaterialTexture;\n\tuniform float materialURepeat;\n\tuniform float materialVRepeat;\n\tuniform sampler2D perfBitmap;\n\tuniform int perfBitmapWidth;\n\tuniform int perfBitmapHeight;\n\tuniform int cropBitmap;\n\tuniform float xcount;\n\tuniform float ycount;\n\tuniform int perfShape;\n\tuniform float minPerf;\n\tuniform float maxPerf;\n\tuniform vec2 rectSize;\n\tuniform float uborder;\n\tuniform float vborder;\n\tuniform vec3 screenRect[4];\n\tuniform vec3 panelRect[4];\n\tuniform vec3 cameraPos;\n\tuniform vec3 cameraTarget;\n\tuniform vec2 screenSize;\n\tuniform int reductionType;\n\tuniform float reductionAngle;\n\tuniform float reductionPercent;\n\tuniform int gridType; // 0:orthogonal, 1:diagonal\n\tuniform vec2 minPerfUV;\n\tuniform vec2 maxPerfUV;\n\tuniform int controlBySize;\n\tuniform int skipShiftedColumn; // when 1, half shifted column in diagonal grid type is skipped\n\tuniform int supersampleReduction;\n\tuniform int supersamplePerforation;\n        uniform int invertPerf; // 0: no inversion, 1: invert perforation range\n\tvarying vec3 vPosition;\n\tvarying vec2 vUV;\n\n#define RAND(co) fract(sin(dot((co).xy ,vec2(12.9898,78.233))) * 43758.5453)\n\n\tfloat bitmapValue(in vec2 uv){\n            vec2 uv2 = vec2(uv);\n\t    if(cropBitmap != 0){\n\t\tfloat imgProportion = float(perfBitmapHeight)/float(perfBitmapWidth);\n\t\tfloat rectProportion = rectSize.y/rectSize.x;\n\t\tif(imgProportion > rectProportion){\n\t\t    uv2.y = (uv.y-(1.0-imgProportion/rectProportion)/2.0)/(imgProportion/rectProportion);\n\t\t}\n\t\telse{\n\t\t    uv2.x = (uv.x-(1.0-rectProportion/imgProportion)/2.0)/(rectProportion/imgProportion);\n\t\t}\n\t    }\n\t    vec4 color = texture2D(perfBitmap,uv2);\n\t    float perf =  1.0 - (color.x + color.y + color.z)/3.0;\n\n\t    if(invertPerf>0){\n\t\tperf = 1.0 - perf;\n\t    }\n\n\t    return perf * (maxPerf - minPerf) + minPerf;\n\t}\n\n\tvec2 uvOnRect(in vec3 pt, in vec3 rectPt11, in vec3 rectPt21, in vec3 rectPt12, in vec3 rectPt22){\n\t\tvec3 udir = rectPt21-rectPt11;\n\t\tvec3 vdir = rectPt12-rectPt11;\n\t\tfloat ulen = length(udir);\n\t\tfloat vlen = length(vdir);\n\t\tudir /= ulen ;\n\t\tvdir /= vlen;\n\t\treturn vec2(dot(pt-rectPt11, udir)/ulen, dot(pt-rectPt11, vdir)/vlen);\n\t}\n    \n        float perfAlpha(in int perfShape, in vec2 uv){\n\t    vec2 uv2 = vec2(uv);\n\t    uv2.x *= xcount;\n\t    uv2.y *= ycount;\n\t    if(gridType==1 && floor(uv2.x)-2.0*(floor(floor(uv2.x)/2.0))==0.0){\n\t\tif(uv2.y < 0.5 || uv2.y > ycount-0.5) return 1.0; // top or bottom half of diagonal grid is skipped\n\t\tuv2.y += 0.5;\n\t    }\n\t    uv2 = fract(uv2);\n\t    uv2.x-=0.5;\n\t    uv2.y-=0.5;\n\t    \n\t    vec2 uv3 = vec2(uv);\n\t    uv3.x = (floor(uv3.x*xcount)+0.5)/xcount;\n\t    if(gridType==1 && floor(uv.x*xcount) -2.0*(floor(floor(uv.x*xcount)/2.0))==0.0){\n\t\tuv3.y = (floor(uv3.y*ycount+0.5)+0.5)/ycount;\n\t    }\n\t    else{\n\t\tuv3.y = (floor(uv3.y*ycount)+0.5)/ycount;\n\t    }\n\t    float perf = bitmapValue(uv3);\n\t    float border = 0.0;\n\t    \n\t    if(perfShape == 1){ // square\n\t\tuv2.x = abs(uv2.x);\n\t\tuv2.y = abs(uv2.y);\n\t\tfloat ax = 1.0;\n\t\tfloat ay = 1.0;\n        \tif(uv2.x < perf/2.0/1.41421-border){\n\t\t\tax = 0.0;\n                }\n\t\telse if(uv2.x < perf/2.0/1.41421+border){\n\t\t    ax = (uv2.x-perf/2.0/1.41421+border)/(border*2.0);\n\t\t}\n        \tif(uv2.y < perf/2.0/1.41421-border){\n\t\t    ay = 0.0;\n                }\n                else if(uv2.y < perf/2.0/1.41421+border){\n\t\t    ay = (uv2.y-perf/2.0/1.41421+border)/(border*2.0);\n                }\n\t\treturn 1.0-(1.0-ax)*(1.0-ay);\n\t    }\n\t    if(perfShape == 2){ // diamond\n\t\tfloat r = abs(uv2.x)+abs(uv2.y);\n\t\tfloat alpha = 1.0;\n\t\tif(r < perf/2.0-border){\n\t\t\talpha = 0.0;\n                }\n                else if(r < perf/2.0+border){\n                \talpha = (r-perf/2.0+border)/(border*2.0);\n                }\n\t\treturn alpha;\n\t    }\n\t    if(perfShape == 3){ // hexagon\n\t\tuv2.x = abs(uv2.x);\n\t\tuv2.y = abs(uv2.y);\n\t\tfloat alphax = 1.0;\n\t\tfloat alphay = 1.0;\n\t\tfloat root3 = sqrt(3.0);\n\t\tif(uv2.y < perf * root3/4.0 - border){\n\t\t\talphay = 0.0;\n\t\t}\n\t\telse if( uv2.y < perf * root3/4.0 + border){\n\t\t\talphay= (uv2.y - perf*root3/4.0 + border)/(border*2.0);\n\t\t}\n\t\tif(uv2.x < -uv2.y/root3 + perf*0.5 - border){\n\t\t\talphax = 0.0;\n\t\t}\n\t\telse if( uv2.x < -uv2.y/root3 + perf*0.5 + border){\n\t\t\talphax = (uv2.x + uv2.y/root3 - perf*0.5 + border)/(border*2.0);\n                }\n\t\treturn 1.0 - (1.0-alphax)*(1.0-alphay);\n\t    }\n\t    \n\t    // round\n\t    float r = sqrt(uv2.x*uv2.x+uv2.y*uv2.y);\n\t    float alpha = 1.0;\n\t    if(r < perf/2.0-border){\n\t\talpha = 0.0;\n\t    }\n\t    else if(r < perf/2.0+border){\n\t\talpha = (r-perf/2.0+border)/(border*2.0);\n\t    }\n\t    return alpha;\n\t}\n\n        float perfAverageAlpha(in int perfShape, in vec2 uv){\n\t    float perf = bitmapValue(uv);\n\n\t    vec2 uv3 = vec2(uv);\n\t    uv3.x += (cameraPos.z)*0.1;\n\t    uv3.y += (cameraPos.y)*0.1;\n\n\t    float r = (RAND(uv3*100.0)-0.5) * 0.15;\n\t    perf += r;\n\t    if(perf<minPerf) perf=minPerf; //\n\t    else if(perf>maxPerf) perf=maxPerf;\n\n\t    if(perfShape==0){ // round\n\t\tperf *= perf/4.0*3.1415926;\n\t    }\n\t    else if(perfShape==1 || perfShape==2){ // square and diamond\n                perf /= 2.0;\n\t    }\n\t    else if(perfShape==3){ //hexagon\n\t\tperf *= 0.64952;\n\t    }\n\t    return perf;\n\t}\n    \n\tfloat reductionProbability(in vec2 uvCenter){\n\t\tif(reductionType>0){\n\t\t\tif(reductionType==1){ // uniform reduction\n\t\t\t\treturn reductionPercent;\n\t\t\t}\n\t\t\telse if(reductionType==2){ // linear gradient\n\t\t\t\tvec2 dir = vec2(cos(reductionAngle), sin(reductionAngle));\n\t\t\t\tfloat dot1 = abs(dot(dir, vec2(-rectSize.x/2.0, -rectSize.y/2.0)));\n\t\t\t\tfloat dot2 = abs(dot(dir, vec2(rectSize.x/2.0, -rectSize.y/2.0)));\n\t\t\t\tfloat dotRange = dot1;\n\t\t\t\tif(dot2>dot1){\n\t\t\t\t\tdotRange = dot2;\n\t\t\t\t}\n\t\t\t\tfloat dot = dot(dir, vec2((uvCenter.x-0.5)*rectSize.x,( uvCenter.y-0.5)*rectSize.y)) / (dotRange*2.0) + 0.5;\n\t\t\t\treturn reductionPercent*dot;\n\n\t\t\t}\n\t\t\telse if(reductionType==3){ // radial gradient\n\t\t\t\tfloat sz = rectSize.x;\n\t\t\t\tif(sz < rectSize.y) sz = rectSize.y;\n\t\t\t\tfloat radius = length(vec2((uvCenter.x-0.5)*rectSize.x,( uvCenter.y-0.5)*rectSize.y))/(sz/2.0);\n\t\t\t\treturn reductionPercent*radius;\n\t\t\t}\n\t\t}\n\t\treturn 0.0;\n\t}\n\n\tbool reductionFilter(in vec2 uvCenter){\n\n\t\tfloat percent = reductionProbability(uvCenter);\n\n\t\tif(percent>0.0){\n\t\t\tvec2 rpos = vec2(uvCenter);\n\t\t\tif(gridType==1 && floor(rpos.x*xcount) -2.0*(floor(floor(rpos.x*xcount)/2.0))==0.0){\n\t\t\t\trpos.y += 0.5/ycount;\n\t\t\t}\n\n\t\t\trpos.x = (floor(rpos.x*xcount)+0.5)/xcount;\n\t\t\trpos.y = (floor(rpos.y*ycount)+0.5)/ycount;\n\t\t\trpos.x *= 100.0;\n\t\t\trpos.y *= 100.0;\n\n\t\t\tfloat r1 = RAND(rpos);\n\n\t\t\tfloat percent = reductionProbability(uvCenter);\n\t\t\tif(r1*100.0 < percent)return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\n        float reductionRatioSample(in vec2 uvCenter, in vec2 uvec, in vec2 vvec, in float i, in float j, float sampleNum){\n\t    vec2 uv = vec2(uvCenter);\n\t    uv += uvec*2.0*(i/sampleNum-0.5);\n\t    uv += vvec*2.0*(j/sampleNum-0.5);\n\t    if(reductionFilter(uv)){\n\t\treturn 1.0; \n\t    }\n\t    return 0.0;\n\t}\n    \n\tfloat perfAlphaBySize(in vec2 uvCenter, in vec2 uvec, in vec2 vvec, in vec3 pos, in vec3 nml){\n\n\t    vec2 rpos = vec2(uvCenter);\n\t    if(gridType==1 && floor(rpos.x*xcount) -2.0*(floor(floor(rpos.x*xcount)/2.0))==0.0){\n\t\t//if(rpos.y*ycount < 0.5 || rpos.y*ycount > ycount-0.5) return 1.0; // top or bottom half of diagonal grid is skipped\n\n\t\tif(skipShiftedColumn>0) return 1.0; // close holes on shifted columns in diagonal mode\n\n\t\trpos.y += 0.5/ycount;\n\t    }\n\n\t    if(controlBySize==0){\n\t\tif(reductionFilter(uvCenter)){\n\t\t    return 1.0;\n\t\t}\n\t\treturn perfAlpha(perfShape, uvCenter);\n\t    }\n\n\t    vec2 uvSize = vec2(max(uvec.x,vvec.x), max(uvec.y,vvec.y));\n\n\t    float uvlen = sqrt(uvSize.x*uvSize.x*xcount*xcount+uvSize.y*uvSize.y*ycount*ycount);\n\n\n\t    // changing threshold by camera angle\n\t    vec3 cdir = cameraTarget-cameraPos;\n\t    float dt = abs(dot(nml,cdir)/(length(nml)*length(cdir)));\n\n\t    float len1 = 0.35; //0.25;\n\t    float len2 = 0.40; //0.45; //0.55; //2.0;\n\t    float len3 = 0.55; //0.55; //0.65; //0.45; //0.7; //4.0;\n\n\t    if(dt>0.001){\n\t\tlen1/=dt*dt;\n\t\tlen2/=dt*dt;\n\t\tlen3/=dt*dt;\n\t    }\n\n\t    float p1 = 0.0;\n\t    float p2 = 0.0;\n\t    float perfRatio = 0.0;\n\n\t    if(supersamplePerforation > 0){\n\n\t\t\tlen1 = 0.25; //0.25;\n\t\t\tlen2 = 0.40; //0.45; //0.55; //2.0;\n\t\t\tlen3 = 1.0; //0.55; //0.65; //0.45; //0.7; //4.0;\n\n\t\t\tif(uvlen < len3) {\n\t\t\t\tperfRatio = perfAlpha(perfShape, uvCenter);\n\t\t\t} else {\n\t\t\t\tperfRatio =  (1.0 - perfAverageAlpha(perfShape, uvCenter));\n\t\t\t}\n\n\t    } else {\n\t\t\tp1 = perfAlpha(perfShape, uvCenter);\n\t\t\tp2 = (1.0 - perfAverageAlpha(perfShape, uvCenter));\n\t\t\tif(uvlen<len1) perfRatio = p1;\n\t\t\telse if(uvlen>len2) perfRatio =  p2;\n\t\t\telse perfRatio =  (uvlen-len1)/(len2-len1)*(p2-p1)+p1;\n\t    }\n\n\t    float reductionRatio = 1.0;\n\t    if(supersampleReduction>0){\n\t\t// 3x3 supersample\n\t\treductionRatio = 0.0;\n\t\treductionRatio += reductionRatioSample(uvCenter,uvec,vvec, 0.0, 0.0, 3.0);\n\t\treductionRatio += reductionRatioSample(uvCenter,uvec,vvec, 0.0, 1.0, 3.0);\n\t\treductionRatio += reductionRatioSample(uvCenter,uvec,vvec, 0.0, 2.0, 3.0);\n\t\treductionRatio += reductionRatioSample(uvCenter,uvec,vvec, 1.0, 0.0, 3.0);\n\t\treductionRatio += reductionRatioSample(uvCenter,uvec,vvec, 1.0, 1.0, 3.0);\n\t\treductionRatio += reductionRatioSample(uvCenter,uvec,vvec, 1.0, 2.0, 3.0);\n\t\treductionRatio += reductionRatioSample(uvCenter,uvec,vvec, 2.0, 0.0, 3.0);\n\t\treductionRatio += reductionRatioSample(uvCenter,uvec,vvec, 2.0, 1.0, 3.0);\n\t\treductionRatio += reductionRatioSample(uvCenter,uvec,vvec, 2.0, 2.0, 3.0);\n\t\treductionRatio /= 9.0;\n\t    }\n\t    else{\n\t\treductionRatio = reductionProbability(uvCenter)/100.0;\n\t    }\n\n\t    bool filtered = reductionFilter(uvCenter);\n\t    if(uvlen < len1){\n\t\tif(filtered) perfRatio = 1.0;\n\t    }\n\t    else if(uvlen < len2){\n\t\tp1 = perfRatio;\n\t\tp2 = perfRatio;\n\t\tif(filtered) p1 = 1.0;\n\n\t\tp2 = p2 + (1.0-p2)*reductionRatio;\n\t\tperfRatio = (uvlen-len1)/(len2-len1)*(p2-p1)+p1;\n\t    }\n\t    else{\n\t\tperfRatio = perfRatio + (1.0 - perfRatio)* reductionRatio;\n\t    }\n\n\t    return perfRatio;\n\t}\n\n\tvec2 offsetBorder(in vec2 uv){\n\t\tvec2 uv2 = vec2(uv);\n\t\tuv2.x -= uborder;\n\t\tuv2.y -= vborder;\n\t\tuv2.x /= (1.0-uborder*2.0);\n\t\tuv2.y /= (1.0-vborder*2.0);\n\t\treturn uv2;\n\t}\n\n\tvoid main(){\n\t    vec2 uv = vec2(vUV);\n\t    vec2 matuv = vec2(uv);\n\t    matuv.x *= materialURepeat;\n\t    matuv.y *= materialVRepeat;\n\t    \n\t    vec4 color;\n\t    \n\t    if(useMaterialTexture == 1){\n\t\tcolor = texture2D(materialTexture, fract(matuv));\n\t    } else {\n\t\tcolor = vec4(materialColor, 1);\n\t    }\n\t    \n\t    vec2 uv2 = offsetBorder(vUV);\n\t    \n\t    vec3 panelNml = cross(panelRect[1] - panelRect[0], panelRect[2]-panelRect[0]);\n\t    \n\t    vec2 minPerfUV2 = offsetBorder(minPerfUV);\n\t    vec2 maxPerfUV2 = offsetBorder(maxPerfUV);\n\t    \n\t    if(uv2.x<minPerfUV2.x || uv2.y<minPerfUV2.y || uv2.x>maxPerfUV2.x || uv2.y>maxPerfUV2.y){\n\t\tcolor.w = 1.0;\n\t\tvec3 cdir = normalize(cameraTarget-cameraPos);\n\t\tpanelNml = normalize(panelNml);\n\t\tcolor.xyz *= abs(dot(panelNml,cdir))*0.5 + 0.5;\n\t\tgl_FragColor = color;\n\t\treturn;\n\t    }\n\t    \n\t    if(uv2.x<0.0 || uv2.y<0.0 || uv2.x>1.0 || uv2.y>1.0){ // border\n\t\tcolor.w = 1.0;\n\t    }\n\t    else{\n\t\tvec3 sdir32 = screenRect[2] - screenRect[3];\n\t\tvec3 sdir31 = screenRect[1] - screenRect[3];\n\t\tvec3 sp1 = sdir32*(gl_FragCoord.x+1.0)/screenSize.x + sdir31*gl_FragCoord.y/screenSize.y + screenRect[3];\n\t\tvec3 sp2 = sdir32*gl_FragCoord.x/screenSize.x + sdir31*(gl_FragCoord.y+1.0)/screenSize.y + screenRect[3];\n\t\t\n\t\tvec3 pdir01 = panelRect[1] - panelRect[0];\n\t\tvec3 pdir02 = panelRect[2] - panelRect[0];\n\t\tvec3 pp0 = pdir01*vUV.x + pdir02*vUV.y + panelRect[0];\n\t\t\n\t\tvec3 dir1 = sp1 - cameraPos;\n\t\tvec3 dir2 = sp2 - cameraPos;\n\t\t\n\t\tvec3 itxn1 = vec3(dir1) * dot(panelNml, pp0-sp1)/dot(panelNml, dir1) + sp1; // intersection\n\t\tvec3 itxn2 = vec3(dir2) * dot(panelNml, pp0-sp2)/dot(panelNml, dir2) + sp2; // intersection\n\t\t\n\t\tvec2 uv_u = uvOnRect(itxn1, panelRect[0], panelRect[1], panelRect[2], panelRect[3]);\n\t\tvec2 uv_v = uvOnRect(itxn2, panelRect[0], panelRect[1], panelRect[2], panelRect[3]);\n\t\t\n\t\tcolor.w = perfAlphaBySize(uv2, vec2(uv_u-vUV), vec2(uv_v-vUV), pp0, panelNml);\n\t    }\n\t    \n\t    vec3 cdir = normalize(cameraTarget-cameraPos);\n\t    panelNml = normalize(panelNml);\n\t    color.xyz *= abs(dot(panelNml,cdir))*0.5 + 0.5;\n\t    gl_FragColor = color;\n\t}\n";
    return FragmentShader;
}());
